{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\caiod\\\\OneDrive\\\\Documentos\\\\GitHub\\\\storm\\\\frontend-storm\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\caiod\\\\OneDrive\\\\Documentos\\\\GitHub\\\\storm\\\\frontend-storm\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\n\nvar GoTrueApi = /*#__PURE__*/function () {\n  function GoTrueApi(_ref) {\n    var _ref$url = _ref.url,\n        url = _ref$url === void 0 ? '' : _ref$url,\n        _ref$headers = _ref.headers,\n        headers = _ref$headers === void 0 ? {} : _ref$headers,\n        cookieOptions = _ref.cookieOptions,\n        fetch = _ref.fetch;\n\n    _classCallCheck(this, GoTrueApi);\n\n    this.url = url;\n    this.headers = headers;\n    this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  _createClass(GoTrueApi, [{\n    key: \"_createRequestHeaders\",\n    value: function _createRequestHeaders(jwt) {\n      var headers = Object.assign({}, this.headers);\n      headers['Authorization'] = \"Bearer \".concat(jwt);\n      return headers;\n    }\n  }, {\n    key: \"cookieName\",\n    value: function cookieName() {\n      var _a;\n\n      return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n\n  }, {\n    key: \"getUrlForProvider\",\n    value: function getUrlForProvider(provider, options) {\n      var urlParams = [\"provider=\".concat(encodeURIComponent(provider))];\n\n      if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        urlParams.push(\"redirect_to=\".concat(encodeURIComponent(options.redirectTo)));\n      }\n\n      if (options === null || options === void 0 ? void 0 : options.scopes) {\n        urlParams.push(\"scopes=\".concat(encodeURIComponent(options.scopes)));\n      }\n\n      return \"\".concat(this.url, \"/authorize?\").concat(urlParams.join('&'));\n    }\n    /**\n     * Creates a new user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n\n  }, {\n    key: \"signUpWithEmail\",\n    value: function signUpWithEmail(email, password) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var headers, queryString, data, session;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '';\n\n                if (options.redirectTo) {\n                  queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n\n                _context.next = 6;\n                return post(this.fetch, \"\".concat(this.url, \"/signup\").concat(queryString), {\n                  email: email,\n                  password: password,\n                  data: options.data,\n                  gotrue_meta_security: {\n                    hcaptcha_token: options.captchaToken\n                  }\n                }, {\n                  headers: headers\n                });\n\n              case 6:\n                data = _context.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](0);\n                return _context.abrupt(\"return\", {\n                  data: null,\n                  error: _context.t0\n                });\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 12]]);\n      }));\n    }\n    /**\n     * Logs in an existing user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"signInWithEmail\",\n    value: function signInWithEmail(email, password) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var headers, queryString, data, session;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '?grant_type=password';\n\n                if (options.redirectTo) {\n                  queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n\n                _context2.next = 6;\n                return post(this.fetch, \"\".concat(this.url, \"/token\").concat(queryString), {\n                  email: email,\n                  password: password\n                }, {\n                  headers: headers\n                });\n\n              case 6:\n                data = _context2.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context2.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](0);\n                return _context2.abrupt(\"return\", {\n                  data: null,\n                  error: _context2.t0\n                });\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 12]]);\n      }));\n    }\n    /**\n     * Signs up a new user using their phone number and a password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     * @param data Optional user metadata.\n     */\n\n  }, {\n    key: \"signUpWithPhone\",\n    value: function signUpWithPhone(phone, password) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var headers, data, session;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                headers = Object.assign({}, this.headers);\n                _context3.next = 4;\n                return post(this.fetch, \"\".concat(this.url, \"/signup\"), {\n                  phone: phone,\n                  password: password,\n                  data: options.data,\n                  gotrue_meta_security: {\n                    hcaptcha_token: options.captchaToken\n                  }\n                }, {\n                  headers: headers\n                });\n\n              case 4:\n                data = _context3.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context3.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 10:\n                _context3.prev = 10;\n                _context3.t0 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", {\n                  data: null,\n                  error: _context3.t0\n                });\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Logs in an existing user using their phone number and password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     */\n\n  }, {\n    key: \"signInWithPhone\",\n    value: function signInWithPhone(phone, password) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var headers, queryString, data, session;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '?grant_type=password';\n                _context4.next = 5;\n                return post(this.fetch, \"\".concat(this.url, \"/token\").concat(queryString), {\n                  phone: phone,\n                  password: password\n                }, {\n                  headers: headers\n                });\n\n              case 5:\n                data = _context4.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context4.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 11:\n                _context4.prev = 11;\n                _context4.t0 = _context4[\"catch\"](0);\n                return _context4.abrupt(\"return\", {\n                  data: null,\n                  error: _context4.t0\n                });\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 11]]);\n      }));\n    }\n    /**\n     * Logs in an OpenID Connect user using their id_token.\n     * @param id_token The IDToken of the user.\n     * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n     * @param provider The provider of the user.\n     * @param client_id The clientID of the user.\n     * @param issuer The issuer of the user.\n     */\n\n  }, {\n    key: \"signInWithOpenIDConnect\",\n    value: function signInWithOpenIDConnect(_ref2) {\n      var id_token = _ref2.id_token,\n          nonce = _ref2.nonce,\n          client_id = _ref2.client_id,\n          issuer = _ref2.issuer,\n          provider = _ref2.provider;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var headers, queryString, data, session;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '?grant_type=id_token';\n                _context5.next = 5;\n                return post(this.fetch, \"\".concat(this.url, \"/token\").concat(queryString), {\n                  id_token: id_token,\n                  nonce: nonce,\n                  client_id: client_id,\n                  issuer: issuer,\n                  provider: provider\n                }, {\n                  headers: headers\n                });\n\n              case 5:\n                data = _context5.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context5.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 11:\n                _context5.prev = 11;\n                _context5.t0 = _context5[\"catch\"](0);\n                return _context5.abrupt(\"return\", {\n                  data: null,\n                  error: _context5.t0\n                });\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 11]]);\n      }));\n    }\n    /**\n     * Sends a magic login link to an email address.\n     * @param email The email address of the user.\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"sendMagicLinkEmail\",\n    value: function sendMagicLinkEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var headers, queryString, shouldCreateUser, data;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '';\n\n                if (options.redirectTo) {\n                  queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n\n                shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                _context6.next = 7;\n                return post(this.fetch, \"\".concat(this.url, \"/otp\").concat(queryString), {\n                  email: email,\n                  create_user: shouldCreateUser,\n                  gotrue_meta_security: {\n                    hcaptcha_token: options.captchaToken\n                  }\n                }, {\n                  headers: headers\n                });\n\n              case 7:\n                data = _context6.sent;\n                return _context6.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 11:\n                _context6.prev = 11;\n                _context6.t0 = _context6[\"catch\"](0);\n                return _context6.abrupt(\"return\", {\n                  data: null,\n                  error: _context6.t0\n                });\n\n              case 14:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 11]]);\n      }));\n    }\n    /**\n     * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n     * @param phone The user's phone number WITH international prefix\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     */\n\n  }, {\n    key: \"sendMobileOTP\",\n    value: function sendMobileOTP(phone) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var shouldCreateUser, headers, data;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                headers = Object.assign({}, this.headers);\n                _context7.next = 5;\n                return post(this.fetch, \"\".concat(this.url, \"/otp\"), {\n                  phone: phone,\n                  create_user: shouldCreateUser,\n                  gotrue_meta_security: {\n                    hcaptcha_token: options.captchaToken\n                  }\n                }, {\n                  headers: headers\n                });\n\n              case 5:\n                data = _context7.sent;\n                return _context7.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 9:\n                _context7.prev = 9;\n                _context7.t0 = _context7[\"catch\"](0);\n                return _context7.abrupt(\"return\", {\n                  data: null,\n                  error: _context7.t0\n                });\n\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 9]]);\n      }));\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     */\n\n  }, {\n    key: \"signOut\",\n    value: function signOut(jwt) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/logout\"), {}, {\n                  headers: this._createRequestHeaders(jwt),\n                  noResolveJson: true\n                });\n\n              case 3:\n                return _context8.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 6:\n                _context8.prev = 6;\n                _context8.t0 = _context8[\"catch\"](0);\n                return _context8.abrupt(\"return\", {\n                  error: _context8.t0\n                });\n\n              case 9:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 6]]);\n      }));\n    }\n    /**\n     * @deprecated Use `verifyOTP` instead!\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"verifyMobileOTP\",\n    value: function verifyMobileOTP(phone, token) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var headers, data, session;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                headers = Object.assign({}, this.headers);\n                _context9.next = 4;\n                return post(this.fetch, \"\".concat(this.url, \"/verify\"), {\n                  phone: phone,\n                  token: token,\n                  type: 'sms',\n                  redirect_to: options.redirectTo\n                }, {\n                  headers: headers\n                });\n\n              case 4:\n                data = _context9.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context9.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 10:\n                _context9.prev = 10;\n                _context9.t0 = _context9[\"catch\"](0);\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  error: _context9.t0\n                });\n\n              case 13:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Send User supplied Email / Mobile OTP to be verified\n     * @param email The user's email address\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param type verification type that the otp is generated for\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"verifyOTP\",\n    value: function verifyOTP(_ref3) {\n      var email = _ref3.email,\n          phone = _ref3.phone,\n          token = _ref3.token,\n          _ref3$type = _ref3.type,\n          type = _ref3$type === void 0 ? 'sms' : _ref3$type;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var headers, data, session;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                headers = Object.assign({}, this.headers);\n                _context10.next = 4;\n                return post(this.fetch, \"\".concat(this.url, \"/verify\"), {\n                  email: email,\n                  phone: phone,\n                  token: token,\n                  type: type,\n                  redirect_to: options.redirectTo\n                }, {\n                  headers: headers\n                });\n\n              case 4:\n                data = _context10.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context10.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 10:\n                _context10.prev = 10;\n                _context10.t0 = _context10[\"catch\"](0);\n                return _context10.abrupt(\"return\", {\n                  data: null,\n                  error: _context10.t0\n                });\n\n              case 13:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata\n     */\n\n  }, {\n    key: \"inviteUserByEmail\",\n    value: function inviteUserByEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var headers, queryString, data;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '';\n\n                if (options.redirectTo) {\n                  queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n\n                _context11.next = 6;\n                return post(this.fetch, \"\".concat(this.url, \"/invite\").concat(queryString), {\n                  email: email,\n                  data: options.data\n                }, {\n                  headers: headers\n                });\n\n              case 6:\n                data = _context11.sent;\n                return _context11.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 10:\n                _context11.prev = 10;\n                _context11.t0 = _context11[\"catch\"](0);\n                return _context11.abrupt(\"return\", {\n                  data: null,\n                  error: _context11.t0\n                });\n\n              case 13:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Sends a reset request to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"resetPasswordForEmail\",\n    value: function resetPasswordForEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var headers, queryString, data;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                headers = Object.assign({}, this.headers);\n                queryString = '';\n\n                if (options.redirectTo) {\n                  queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n\n                _context12.next = 6;\n                return post(this.fetch, \"\".concat(this.url, \"/recover\").concat(queryString), {\n                  email: email,\n                  gotrue_meta_security: {\n                    hcaptcha_token: options.captchaToken\n                  }\n                }, {\n                  headers: headers\n                });\n\n              case 6:\n                data = _context12.sent;\n                return _context12.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 10:\n                _context12.prev = 10;\n                _context12.t0 = _context12[\"catch\"](0);\n                return _context12.abrupt(\"return\", {\n                  data: null,\n                  error: _context12.t0\n                });\n\n              case 13:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n\n  }, {\n    key: \"refreshAccessToken\",\n    value: function refreshAccessToken(refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var data, session;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n                _context13.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/token?grant_type=refresh_token\"), {\n                  refresh_token: refreshToken\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context13.sent;\n                session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n                return _context13.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 9:\n                _context13.prev = 9;\n                _context13.t0 = _context13[\"catch\"](0);\n                return _context13.abrupt(\"return\", {\n                  data: null,\n                  error: _context13.t0\n                });\n\n              case 12:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 9]]);\n      }));\n    }\n    /**\n     * Set/delete the auth cookie based on the AuthChangeEvent.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     * @param req The request object.\n     * @param res The response object.\n     */\n\n  }, {\n    key: \"setAuthCookie\",\n    value: function setAuthCookie(req, res) {\n      var _this = this;\n\n      if (req.method !== 'POST') {\n        res.setHeader('Allow', 'POST');\n        res.status(405).end('Method Not Allowed');\n      }\n\n      var _req$body = req.body,\n          event = _req$body.event,\n          session = _req$body.session;\n      if (!event) throw new Error('Auth event missing!');\n\n      if (event === 'SIGNED_IN') {\n        if (!session) throw new Error('Auth session missing!');\n        setCookies(req, res, [{\n          key: 'access-token',\n          value: session.access_token\n        }, {\n          key: 'refresh-token',\n          value: session.refresh_token\n        }].map(function (token) {\n          var _a;\n\n          return {\n            name: \"\".concat(_this.cookieName(), \"-\").concat(token.key),\n            value: token.value,\n            domain: _this.cookieOptions.domain,\n            maxAge: (_a = _this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n            path: _this.cookieOptions.path,\n            sameSite: _this.cookieOptions.sameSite\n          };\n        }));\n      }\n\n      if (event === 'SIGNED_OUT') {\n        setCookies(req, res, ['access-token', 'refresh-token'].map(function (key) {\n          return {\n            name: \"\".concat(_this.cookieName(), \"-\").concat(key),\n            value: '',\n            maxAge: -1\n          };\n        }));\n      }\n\n      res.status(200).json({});\n    }\n    /**\n     * Deletes the Auth Cookies and redirects to the\n     * @param req The request object.\n     * @param res The response object.\n     * @param options Optionally specify a `redirectTo` URL in the options.\n     */\n\n  }, {\n    key: \"deleteAuthCookie\",\n    value: function deleteAuthCookie(req, res, _ref4) {\n      var _this2 = this;\n\n      var _ref4$redirectTo = _ref4.redirectTo,\n          redirectTo = _ref4$redirectTo === void 0 ? '/' : _ref4$redirectTo;\n      setCookies(req, res, ['access-token', 'refresh-token'].map(function (key) {\n        return {\n          name: \"\".concat(_this2.cookieName(), \"-\").concat(key),\n          value: '',\n          maxAge: -1\n        };\n      }));\n      return res.redirect(307, redirectTo);\n    }\n    /**\n     * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n     * @param req The request object.\n     * @param res The response object.\n     * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n     */\n\n  }, {\n    key: \"getAuthCookieString\",\n    value: function getAuthCookieString(req, res) {\n      var _this3 = this;\n\n      if (req.method !== 'POST') {\n        res.setHeader('Allow', 'POST');\n        res.status(405).end('Method Not Allowed');\n      }\n\n      var _req$body2 = req.body,\n          event = _req$body2.event,\n          session = _req$body2.session;\n      if (!event) throw new Error('Auth event missing!');\n\n      if (event === 'SIGNED_IN') {\n        if (!session) throw new Error('Auth session missing!');\n        return getCookieString(req, res, [{\n          key: 'access-token',\n          value: session.access_token\n        }, {\n          key: 'refresh-token',\n          value: session.refresh_token\n        }].map(function (token) {\n          var _a;\n\n          return {\n            name: \"\".concat(_this3.cookieName(), \"-\").concat(token.key),\n            value: token.value,\n            domain: _this3.cookieOptions.domain,\n            maxAge: (_a = _this3.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n            path: _this3.cookieOptions.path,\n            sameSite: _this3.cookieOptions.sameSite\n          };\n        }));\n      }\n\n      if (event === 'SIGNED_OUT') {\n        return getCookieString(req, res, ['access-token', 'refresh-token'].map(function (key) {\n          return {\n            name: \"\".concat(_this3.cookieName(), \"-\").concat(key),\n            value: '',\n            maxAge: -1\n          };\n        }));\n      }\n\n      return res.getHeader('Set-Cookie');\n    }\n    /**\n     * Generates links to be sent via email or other.\n     * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     * @param email The user's email.\n     * @param password User password. For signup only.\n     * @param data Optional user metadata. For signup only.\n     * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     */\n\n  }, {\n    key: \"generateLink\",\n    value: function generateLink(type, email) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.prev = 0;\n                _context14.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/admin/generate_link\"), {\n                  type: type,\n                  email: email,\n                  password: options.password,\n                  data: options.data,\n                  redirect_to: options.redirectTo\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context14.sent;\n                return _context14.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context14.prev = 7;\n                _context14.t0 = _context14[\"catch\"](0);\n                return _context14.abrupt(\"return\", {\n                  data: null,\n                  error: _context14.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[0, 7]]);\n      }));\n    } // User Admin API\n\n    /**\n     * Creates a new user.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param attributes The data you want to create the user with.\n     */\n\n  }, {\n    key: \"createUser\",\n    value: function createUser(attributes) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.prev = 0;\n                _context15.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/admin/users\"), attributes, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context15.sent;\n                return _context15.abrupt(\"return\", {\n                  user: data,\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context15.prev = 7;\n                _context15.t0 = _context15[\"catch\"](0);\n                return _context15.abrupt(\"return\", {\n                  user: null,\n                  data: null,\n                  error: _context15.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n\n  }, {\n    key: \"listUsers\",\n    value: function listUsers() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.prev = 0;\n                _context16.next = 3;\n                return get(this.fetch, \"\".concat(this.url, \"/admin/users\"), {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context16.sent;\n                return _context16.abrupt(\"return\", {\n                  data: data.users,\n                  error: null\n                });\n\n              case 7:\n                _context16.prev = 7;\n                _context16.t0 = _context16[\"catch\"](0);\n                return _context16.abrupt(\"return\", {\n                  data: null,\n                  error: _context16.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n\n  }, {\n    key: \"getUserById\",\n    value: function getUserById(uid) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.prev = 0;\n                _context17.next = 3;\n                return get(this.fetch, \"\".concat(this.url, \"/admin/users/\").concat(uid), {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context17.sent;\n                return _context17.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context17.prev = 7;\n                _context17.t0 = _context17[\"catch\"](0);\n                return _context17.abrupt(\"return\", {\n                  data: null,\n                  error: _context17.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Get user by reading the cookie from the request.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     */\n\n  }, {\n    key: \"getUserByCookie\",\n    value: function getUserByCookie(req, res) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var _this4 = this;\n\n        var access_token, refresh_token, _yield$this$getUser, user, getUserError, _yield$this$refreshAc, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.prev = 0;\n\n                if (req.cookies) {\n                  _context18.next = 3;\n                  break;\n                }\n\n                throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n\n              case 3:\n                access_token = req.cookies[\"\".concat(this.cookieName(), \"-access-token\")];\n                refresh_token = req.cookies[\"\".concat(this.cookieName(), \"-refresh-token\")];\n\n                if (access_token) {\n                  _context18.next = 7;\n                  break;\n                }\n\n                throw new Error('No cookie found!');\n\n              case 7:\n                _context18.next = 9;\n                return this.getUser(access_token);\n\n              case 9:\n                _yield$this$getUser = _context18.sent;\n                user = _yield$this$getUser.user;\n                getUserError = _yield$this$getUser.error;\n\n                if (!getUserError) {\n                  _context18.next = 29;\n                  break;\n                }\n\n                if (refresh_token) {\n                  _context18.next = 15;\n                  break;\n                }\n\n                throw new Error('No refresh_token cookie found!');\n\n              case 15:\n                if (res) {\n                  _context18.next = 17;\n                  break;\n                }\n\n                throw new Error('You need to pass the res object to automatically refresh the session!');\n\n              case 17:\n                _context18.next = 19;\n                return this.refreshAccessToken(refresh_token);\n\n              case 19:\n                _yield$this$refreshAc = _context18.sent;\n                data = _yield$this$refreshAc.data;\n                error = _yield$this$refreshAc.error;\n\n                if (!error) {\n                  _context18.next = 26;\n                  break;\n                }\n\n                throw error;\n\n              case 26:\n                if (!data) {\n                  _context18.next = 29;\n                  break;\n                }\n\n                setCookies(req, res, [{\n                  key: 'access-token',\n                  value: data.access_token\n                }, {\n                  key: 'refresh-token',\n                  value: data.refresh_token\n                }].map(function (token) {\n                  var _a;\n\n                  return {\n                    name: \"\".concat(_this4.cookieName(), \"-\").concat(token.key),\n                    value: token.value,\n                    domain: _this4.cookieOptions.domain,\n                    maxAge: (_a = _this4.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                    path: _this4.cookieOptions.path,\n                    sameSite: _this4.cookieOptions.sameSite\n                  };\n                }));\n                return _context18.abrupt(\"return\", {\n                  token: data.access_token,\n                  user: data.user,\n                  data: data.user,\n                  error: null\n                });\n\n              case 29:\n                return _context18.abrupt(\"return\", {\n                  token: access_token,\n                  user: user,\n                  data: user,\n                  error: null\n                });\n\n              case 32:\n                _context18.prev = 32;\n                _context18.t0 = _context18[\"catch\"](0);\n                return _context18.abrupt(\"return\", {\n                  token: null,\n                  user: null,\n                  data: null,\n                  error: _context18.t0\n                });\n\n              case 35:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[0, 32]]);\n      }));\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n\n  }, {\n    key: \"updateUserById\",\n    value: function updateUserById(uid, attributes) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.prev = 0;\n                this; //\n\n                _context19.next = 4;\n                return put(this.fetch, \"\".concat(this.url, \"/admin/users/\").concat(uid), attributes, {\n                  headers: this.headers\n                });\n\n              case 4:\n                data = _context19.sent;\n                return _context19.abrupt(\"return\", {\n                  user: data,\n                  data: data,\n                  error: null\n                });\n\n              case 8:\n                _context19.prev = 8;\n                _context19.t0 = _context19[\"catch\"](0);\n                return _context19.abrupt(\"return\", {\n                  user: null,\n                  data: null,\n                  error: _context19.t0\n                });\n\n              case 11:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this, [[0, 8]]);\n      }));\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param uid The user uid you want to remove.\n     */\n\n  }, {\n    key: \"deleteUser\",\n    value: function deleteUser(uid) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.prev = 0;\n                _context20.next = 3;\n                return remove(this.fetch, \"\".concat(this.url, \"/admin/users/\").concat(uid), {}, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context20.sent;\n                return _context20.abrupt(\"return\", {\n                  user: data,\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context20.prev = 7;\n                _context20.t0 = _context20[\"catch\"](0);\n                return _context20.abrupt(\"return\", {\n                  user: null,\n                  data: null,\n                  error: _context20.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Gets the current user details.\n     *\n     * This method is called by the GoTrueClient `update` where\n     * the jwt is set to this.currentSession.access_token\n     * and therefore, acts like getting the currently authenticated used\n     *\n     * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function getUser(jwt) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.prev = 0;\n                _context21.next = 3;\n                return get(this.fetch, \"\".concat(this.url, \"/user\"), {\n                  headers: this._createRequestHeaders(jwt)\n                });\n\n              case 3:\n                data = _context21.sent;\n                return _context21.abrupt(\"return\", {\n                  user: data,\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context21.prev = 7;\n                _context21.t0 = _context21[\"catch\"](0);\n                return _context21.abrupt(\"return\", {\n                  user: null,\n                  data: null,\n                  error: _context21.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Updates the user data.\n     * @param jwt A valid, logged-in JWT.\n     * @param attributes The data you want to update.\n     */\n\n  }, {\n    key: \"updateUser\",\n    value: function updateUser(jwt, attributes) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.prev = 0;\n                _context22.next = 3;\n                return put(this.fetch, \"\".concat(this.url, \"/user\"), attributes, {\n                  headers: this._createRequestHeaders(jwt)\n                });\n\n              case 3:\n                data = _context22.sent;\n                return _context22.abrupt(\"return\", {\n                  user: data,\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context22.prev = 7;\n                _context22.t0 = _context22[\"catch\"](0);\n                return _context22.abrupt(\"return\", {\n                  user: null,\n                  data: null,\n                  error: _context22.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this, [[0, 7]]);\n      }));\n    }\n  }]);\n\n  return GoTrueApi;\n}();\n\nexport { GoTrueApi as default };","map":null,"metadata":{},"sourceType":"module"}