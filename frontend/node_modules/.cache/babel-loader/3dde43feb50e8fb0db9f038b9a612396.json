{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\caiod\\\\OneDrive\\\\Documentos\\\\GitHub\\\\storm\\\\frontend-storm\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\caiod\\\\OneDrive\\\\Documentos\\\\GitHub\\\\storm\\\\frontend-storm\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\n\nvar RealtimeChannel = /*#__PURE__*/function () {\n  function RealtimeChannel(topic) {\n    var _this = this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var socket = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, RealtimeChannel);\n\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = [];\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(function () {\n      return _this.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', function () {\n      _this.state = CHANNEL_STATES.joined;\n\n      _this.rejoinTimer.reset();\n\n      _this.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n\n      _this.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this.rejoinTimer.reset();\n\n      _this.socket.log('channel', \"close \".concat(_this.topic, \" \").concat(_this.joinRef()));\n\n      _this.state = CHANNEL_STATES.closed;\n\n      _this.socket.remove(_this);\n    });\n    this.onError(function (reason) {\n      if (_this.isLeaving() || _this.isClosed()) {\n        return;\n      }\n\n      _this.socket.log('channel', \"error \".concat(_this.topic), reason);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', function () {\n      if (!_this.isJoining()) {\n        return;\n      }\n\n      _this.socket.log('channel', \"timeout \".concat(_this.topic), _this.joinPush.timeout);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, {}, function (payload, ref) {\n      _this.trigger(_this.replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n  }\n\n  _createClass(RealtimeChannel, [{\n    key: \"list\",\n    value: function list() {\n      return this.presence.list();\n    }\n  }, {\n    key: \"rejoinUntilConnected\",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.joinedOnce) {\n        throw \"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance\";\n      } else {\n        var configs = this.bindings.reduce(function (acc, binding) {\n          var type = binding.type;\n\n          if (!['phx_close', 'phx_error', 'phx_reply', 'presence_diff', 'presence_state'].includes(type)) {\n            acc[type] = binding;\n          }\n\n          return acc;\n        }, {});\n\n        if (Object.keys(configs).length) {\n          this.updateJoinPayload({\n            configs: configs\n          });\n        }\n\n        this.joinedOnce = true;\n        this.rejoin(timeout);\n        return this.joinPush;\n      }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, {}, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(type, filter, callback) {\n      this.bindings.push({\n        type: type,\n        filter: filter !== null && filter !== void 0 ? filter : {},\n        callback: callback !== null && callback !== void 0 ? callback : function () {}\n      });\n    }\n  }, {\n    key: \"off\",\n    value: function off(type, filter) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return !(bind.type === type && RealtimeChannel.isEqual(bind.filter, filter));\n      });\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     */\n\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n      if (!this.joinedOnce) {\n        throw \"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.subscribe() before pushing events\");\n      }\n\n      var pushEvent = new Push(this, event, payload, timeout);\n\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n  }, {\n    key: \"updateJoinPayload\",\n    value: function updateJoinPayload(payload) {\n      this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this2 = this;\n\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      this.state = CHANNEL_STATES.leaving;\n\n      var onClose = function onClose() {\n        _this2.socket.log('channel', \"leave \".concat(_this2.topic));\n\n        _this2.trigger(CHANNEL_EVENTS.close, 'leave', _this2.joinRef());\n      }; // Destroy joinPush to avoid connection timeouts during unscription phase\n\n\n      this.joinPush.destroy();\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', function () {\n        return onClose();\n      }).receive('timeout', function () {\n        return onClose();\n      });\n      leavePush.send();\n\n      if (!this.canPush()) {\n        leavePush.trigger('ok', {});\n      }\n\n      return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    }\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic) {\n      return this.topic === topic;\n    }\n  }, {\n    key: \"joinRef\",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.isLeaving()) {\n        return;\n      }\n\n      this.socket.leaveOpenTopic(this.topic);\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(type, payload, ref) {\n      var close = CHANNEL_EVENTS.close,\n          error = CHANNEL_EVENTS.error,\n          leave = CHANNEL_EVENTS.leave,\n          join = CHANNEL_EVENTS.join;\n      var events = [close, error, leave, join];\n\n      if (ref && events.indexOf(type) >= 0 && ref !== this.joinRef()) {\n        return;\n      }\n\n      var handledPayload = this.onMessage(type, payload, ref);\n\n      if (payload && !handledPayload) {\n        throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n      }\n\n      this.bindings.filter(function (bind) {\n        var _a, _b;\n\n        return (bind === null || bind === void 0 ? void 0 : bind.type) === type && (((_a = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_b = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _b === void 0 ? void 0 : _b.event) === (payload === null || payload === void 0 ? void 0 : payload.event));\n      }).map(function (bind) {\n        return bind.callback(handledPayload, ref);\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(payload) {\n      var push = this.push(payload.type, payload);\n      return new Promise(function (resolve, reject) {\n        push.receive('ok', function () {\n          return resolve('ok');\n        });\n        push.receive('timeout', function () {\n          return reject('timeout');\n        });\n      });\n    }\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\".concat(ref);\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n  }, {\n    key: \"isErrored\",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n  }, {\n    key: \"isJoined\",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: \"isJoining\",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n  }, {\n    key: \"isLeaving\",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }], [{\n    key: \"isEqual\",\n    value: function isEqual(obj1, obj2) {\n      if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n        return false;\n      }\n\n      for (var k in obj1) {\n        if (obj1[k] !== obj2[k]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return RealtimeChannel;\n}();\n\nexport { RealtimeChannel as default };","map":null,"metadata":{},"sourceType":"module"}